((A, w) ->
  ma = ->
    unless c.isReady
      try
        s.documentElement.doScroll "left"
      catch a
        setTimeout ma, 1
        return
      c.ready()
  Qa = (a, b) ->
    (if b.src then c.ajax(
      url: b.src
      async: false
      dataType: "script"
    ) else c.globalEval(b.text or b.textContent or b.innerHTML or ""))
    b.parentNode and b.parentNode.removeChild(b)
  X = (a, b, d, f, e, j) ->
    i = a.length
    if typeof b is "object"
      for o of b
        X a, o, b[o], f, e, d
      return a
    if d isnt w
      f = not j and f and c.isFunction(d)
      o = 0
      while o < i
        e a[o], b, (if f then d.call(a[o], o, e(a[o], b)) else d), j
        o++
      return a
    (if i then e(a[0], b) else w)
  J = ->
    (new Date).getTime()
  Y = ->
    false
  Z = ->
    true
  na = (a, b, d) ->
    d[0].type = a
    c.event.handle.apply b, d
  oa = (a) ->
    b = undefined
    d = []
    f = []
    e = arguments_
    j = undefined
    i = undefined
    o = undefined
    k = undefined
    n = undefined
    r = undefined
    i = c.data(this, "events")
    unless a.liveFired is this or not i or not i.live or a.button and a.type is "click"
      a.liveFired = this
      u = i.live.slice(0)
      k = 0
      while k < u.length
        i = u[k]
        (if i.origType.replace(O, "") is a.type then f.push(i.selector) else u.splice(k--, 1))
        k++
      j = c(a.target).closest(f, a.currentTarget)
      n = 0
      r = j.length
      while n < r
        k = 0
        while k < u.length
          i = u[k]
          if j[n].selector is i.selector
            o = j[n].elem
            f = null
            f = c(a.relatedTarget).closest(i.selector)[0]  if i.preType is "mouseenter" or i.preType is "mouseleave"
            if not f or f isnt o
              d.push
                elem: o
                handleObj: i

          k++
        n++
      n = 0
      r = d.length
      while n < r
        j = d[n]
        a.currentTarget = j.elem
        a.data = j.handleObj.data
        a.handleObj = j.handleObj
        if j.handleObj.origHandler.apply(j.elem, e) is false
          b = false
          break
        n++
      b
  pa = (a, b) ->
    "live." + ((if a and a isnt "*" then a + "." else "")) + b.replace(/\./g, "`").replace(RegExp(" ", "g"), "&")
  qa = (a) ->
    not a or not a.parentNode or a.parentNode.nodeType is 11
  ra = (a, b) ->
    d = 0
    b.each ->
      if @nodeName is (a[d] and a[d].nodeName)
        f = c.data(a[d++])
        e = c.data(this, f)
        if f = f and f.events
          delete e.handle

          e.events = {}
          for j of f
            for i of f[j]
              c.event.add this, j, f[j][i], f[j][i].data

  sa = (a, b, d) ->
    f = undefined
    e = undefined
    j = undefined
    b = (if b and b[0] then b[0].ownerDocument or b[0] else s)
    if a.length is 1 and typeof a[0] is "string" and a[0].length < 512 and b is s and not ta.test(a[0]) and (c.support.checkClone or not ua.test(a[0]))
      e = true
      f = j  if j isnt 1  if j = c.fragments[a[0]]
    unless f
      f = b.createDocumentFragment()
      c.clean a, b, f, d
    c.fragments[a[0]] = (if j then f else 1)  if e
    fragment: f
    cacheable: e
  K = (a, b) ->
    d = {}
    c.each va.concat.apply([], va.slice(0, b)), ->
      d[this] = a

    d
  wa = (a) ->
    (if "scrollTo" of a and a.document then a else (if a.nodeType is 9 then a.defaultView or a.parentWindow else false))
  c = (a, b) ->
    new c.fn.init(a, b)

  Ra = A.jQuery
  Sa = A.$
  s = A.document
  T = undefined
  Ta = /^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/
  Ua = /^.[^:#\[\.,]*$/
  Va = /\S/
  Wa = /^(\s|\u00A0)+|(\s|\u00A0)+$/g
  Xa = /^<(\w+)\s*\/?>(?:<\/\1>)?$/
  P = navigator.userAgent
  xa = false
  Q = []
  L = undefined
  $ = Object::toString
  aa = Object::hasOwnProperty
  ba = Array::push
  R = Array::slice
  ya = Array::indexOf
  c.fn = c:: =
    init: (a, b) ->
      d = undefined
      f = undefined
      return this  unless a
      if a.nodeType
        @context = this[0] = a
        @length = 1
        return this
      if a is "body" and not b
        @context = s
        this[0] = s.body
        @selector = "body"
        @length = 1
        return this
      if typeof a is "string"
        if (d = Ta.exec(a)) and (d[1] or not b)
          if d[1]
            f = (if b then b.ownerDocument or b else s)
            unless a = Xa.exec(a)
              a = sa([d[1]], [f])
              a = ((if a.cacheable then a.fragment.cloneNode(true) else a.fragment)).childNodes
            return c.merge(this, a)
          else
            if b = s.getElementById(d[2])
              return T.find(a)  if b.id isnt d[2]
              @length = 1
              this[0] = b
            @context = s
            @selector = a
            return this
        else if not b and /^\w+$/.test(a)
          @selector = a
          @context = s
          a = s.getElementsByTagName(a)
          return c.merge(this, a)
        else
          return (if not b or b.jquery then (b or T).find(a) else c(b).find(a))
      else return T.ready(a)  if c.isFunction(a)
      if a.selector isnt w
        @selector = a.selector
        @context = a.context
      c.makeArray a, this

    selector: ""
    jquery: "1.4.2"
    length: 0
    size: ->
      @length

    toArray: ->
      R.call this, 0

    get: (a) ->
      (if not a? then @toArray() else (if a < 0 then @slice(a)[0] else this[a]))

    pushStack: (a, b, d) ->
      f = c()
      (if c.isArray(a) then ba.apply(f, a) else c.merge(f, a))
      f.prevObject = this
      f.context = @context
      if b is "find"
        f.selector = @selector + ((if @selector then " " else "")) + d
      else f.selector = @selector + "." + b + "(" + d + ")"  if b
      f

    each: (a, b) ->
      c.each this, a, b

    ready: (a) ->
      c.bindReady()
      if c.isReady
        a.call s, c
      else
        Q and Q.push(a)
      this

    eq: (a) ->
      (if a is -1 then @slice(a) else @slice(a, +a + 1))

    first: ->
      @eq 0

    last: ->
      @eq -1

    slice: ->
      @pushStack R.apply(this, arguments_), "slice", R.call(arguments_).join(",")

    map: (a) ->
      @pushStack c.map(this, (b, d) ->
        a.call b, d, b
      )

    end: ->
      @prevObject or c(null)

    push: ba
    sort: [].sort
    splice: [].splice

  c.fn.init:: = c.fn
  c.extend = c.fn.extend = ->
    a = arguments_[0] or {}
    b = 1
    d = arguments_.length
    f = false
    e = undefined
    j = undefined
    i = undefined
    o = undefined
    if typeof a is "boolean"
      f = a
      a = arguments_[1] or {}
      b = 2
    a = {}  if typeof a isnt "object" and not c.isFunction(a)
    if d is b
      a = this
      --b
    while b < d
      if (e = arguments_[b])?
        for j of e
          i = a[j]
          o = e[j]
          if a isnt o
            if f and o and (c.isPlainObject(o) or c.isArray(o))
              i = (if i and (c.isPlainObject(i) or c.isArray(i)) then i else (if c.isArray(o) then [] else {}))
              a[j] = c.extend(f, i, o)
            else a[j] = o  if o isnt w
      b++
    a

  c.extend
    noConflict: (a) ->
      A.$ = Sa
      A.jQuery = Ra  if a
      c

    isReady: false
    ready: ->
      unless c.isReady
        return setTimeout(c.ready, 13)  unless s.body
        c.isReady = true
        if Q
          a = undefined
          b = 0

          while a = Q[b++]
            a.call s, c
          Q = null
        c.fn.triggerHandler and c(s).triggerHandler("ready")

    bindReady: ->
      unless xa
        xa = true
        return c.ready()  if s.readyState is "complete"
        if s.addEventListener
          s.addEventListener "DOMContentLoaded", L, false
          A.addEventListener "load", c.ready, false
        else if s.attachEvent
          s.attachEvent "onreadystatechange", L
          A.attachEvent "onload", c.ready
          a = false
          try
            a = not A.frameElement?
          s.documentElement.doScroll and a and ma()

    isFunction: (a) ->
      $.call(a) is "[object Function]"

    isArray: (a) ->
      $.call(a) is "[object Array]"

    isPlainObject: (a) ->
      return false  if not a or $.call(a) isnt "[object Object]" or a.nodeType or a.setInterval
      return false  if a.constructor and not aa.call(a, "constructor") and not aa.call(a.constructor::, "isPrototypeOf")
      b = undefined
      for b of a

      b is w or aa.call(a, b)

    isEmptyObject: (a) ->
      for b of a
        return false
      true

    error: (a) ->
      throw a

    parseJSON: (a) ->
      return null  if typeof a isnt "string" or not a
      a = c.trim(a)
      if /^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))
        (if A.JSON and A.JSON.parse then A.JSON.parse(a) else (new Function("return " + a))())
      else
        c.error "Invalid JSON: " + a

    noop: ->

    globalEval: (a) ->
      if a and Va.test(a)
        b = s.getElementsByTagName("head")[0] or s.documentElement
        d = s.createElement("script")
        d.type = "text/javascript"
        if c.support.scriptEval
          d.appendChild s.createTextNode(a)
        else
          d.text = a
        b.insertBefore d, b.firstChild
        b.removeChild d

    nodeName: (a, b) ->
      a.nodeName and a.nodeName.toUpperCase() is b.toUpperCase()

    each: (a, b, d) ->
      f = undefined
      e = 0
      j = a.length
      i = j is w or c.isFunction(a)
      if d
        if i
          for f of a
            break  if b.apply(a[f], d) is false
        else
          while e < j
            break  if b.apply(a[e++], d) is false
      else if i
        for f of a
          break  if b.call(a[f], f, a[f]) is false
      else
        d = a[0]
        while e < j and b.call(d, e, d) isnt false
          d = a[++e]
      a

    trim: (a) ->
      (a or "").replace Wa, ""

    makeArray: (a, b) ->
      b = b or []
      (if not a.length? or typeof a is "string" or c.isFunction(a) or typeof a isnt "function" and a.setInterval then ba.call(b, a) else c.merge(b, a))  if a?
      b

    inArray: (a, b) ->
      return b.indexOf(a)  if b.indexOf
      d = 0
      f = b.length

      while d < f
        return d  if b[d] is a
        d++
      -1

    merge: (a, b) ->
      d = a.length
      f = 0
      if typeof b.length is "number"
        e = b.length

        while f < e
          a[d++] = b[f]
          f++
      else
        while b[f] isnt w
          a[d++] = b[f++]
      a.length = d
      a

    grep: (a, b, d) ->
      f = []
      e = 0
      j = a.length

      while e < j
        not d isnt not b(a[e], e) and f.push(a[e])
        e++
      f

    map: (a, b, d) ->
      f = []
      e = undefined
      j = 0
      i = a.length

      while j < i
        e = b(a[j], j, d)
        f[f.length] = e  if e?
        j++
      f.concat.apply [], f

    guid: 1
    proxy: (a, b, d) ->
      if arguments_.length is 2
        if typeof b is "string"
          d = a
          a = d[b]
          b = w
        else if b and not c.isFunction(b)
          d = b
          b = w
      if not b and a
        b = ->
          a.apply d or this, arguments_
      b.guid = a.guid = a.guid or b.guid or c.guid++  if a
      b

    uaMatch: (a) ->
      a = a.toLowerCase()
      a = /(webkit)[ \/]([\w.]+)/.exec(a) or /(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a) or /(msie) ([\w.]+)/.exec(a) or not /compatible/.test(a) and /(mozilla)(?:.*? rv:([\w.]+))?/.exec(a) or []
      browser: a[1] or ""
      version: a[2] or "0"

    browser: {}

  P = c.uaMatch(P)
  if P.browser
    c.browser[P.browser] = true
    c.browser.version = P.version
  c.browser.safari = true  if c.browser.webkit
  if ya
    c.inArray = (a, b) ->
      ya.call b, a
  T = c(s)
  if s.addEventListener
    L = ->
      s.removeEventListener "DOMContentLoaded", L, false
      c.ready()
  else if s.attachEvent
    L = ->
      if s.readyState is "complete"
        s.detachEvent "onreadystatechange", L
        c.ready()
  (->
    c.support = {}
    a = s.documentElement
    b = s.createElement("script")
    d = s.createElement("div")
    f = "script" + J()
    d.style.display = "none"
    d.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>"
    e = d.getElementsByTagName("*")
    j = d.getElementsByTagName("a")[0]
    unless not e or not e.length or not j
      c.support =
        leadingWhitespace: d.firstChild.nodeType is 3
        tbody: not d.getElementsByTagName("tbody").length
        htmlSerialize: !!d.getElementsByTagName("link").length
        style: /red/.test(j.getAttribute("style"))
        hrefNormalized: j.getAttribute("href") is "/a"
        opacity: /^0.55$/.test(j.style.opacity)
        cssFloat: !!j.style.cssFloat
        checkOn: d.getElementsByTagName("input")[0].value is "on"
        optSelected: s.createElement("select").appendChild(s.createElement("option")).selected
        parentNode: d.removeChild(d.appendChild(s.createElement("div"))).parentNode is null
        deleteExpando: true
        checkClone: false
        scriptEval: false
        noCloneEvent: true
        boxModel: null

      b.type = "text/javascript"
      try
        b.appendChild s.createTextNode("window." + f + "=1;")
      a.insertBefore b, a.firstChild
      if A[f]
        c.support.scriptEval = true
        delete A[f]
      try
        delete b.test
      catch o
        c.support.deleteExpando = false
      a.removeChild b
      if d.attachEvent and d.fireEvent
        d.attachEvent "onclick", k = ->
          c.support.noCloneEvent = false
          d.detachEvent "onclick", k

        d.cloneNode(true).fireEvent "onclick"
      d = s.createElement("div")
      d.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>"
      a = s.createDocumentFragment()
      a.appendChild d.firstChild
      c.support.checkClone = a.cloneNode(true).cloneNode(true).lastChild.checked
      c ->
        k = s.createElement("div")
        k.style.width = k.style.paddingLeft = "1px"
        s.body.appendChild k
        c.boxModel = c.support.boxModel = k.offsetWidth is 2
        s.body.removeChild(k).style.display = "none"

      a = (k) ->
        n = s.createElement("div")
        k = "on" + k
        r = k of n
        unless r
          n.setAttribute k, "return;"
          r = typeof n[k] is "function"
        r

      c.support.submitBubbles = a("submit")
      c.support.changeBubbles = a("change")
      a = b = d = e = j = null
  )()
  c.props =
    for: "htmlFor"
    class: "className"
    readonly: "readOnly"
    maxlength: "maxLength"
    cellspacing: "cellSpacing"
    rowspan: "rowSpan"
    colspan: "colSpan"
    tabindex: "tabIndex"
    usemap: "useMap"
    frameborder: "frameBorder"

  G = "jQuery" + J()
  Ya = 0
  za = {}
  c.extend
    cache: {}
    expando: G
    noData:
      embed: true
      object: true
      applet: true

    data: (a, b, d) ->
      unless a.nodeName and c.noData[a.nodeName.toLowerCase()]
        a = (if a is A then za else a)
        f = a[G]
        e = c.cache
        return null  if not f and typeof b is "string" and d is w
        f or (f = ++Ya)
        if typeof b is "object"
          a[G] = f
          e[f] = c.extend(true, {}, b)
        else unless e[f]
          a[G] = f
          e[f] = {}
        a = e[f]
        a[b] = d  if d isnt w
        (if typeof b is "string" then a[b] else a)

    removeData: (a, b) ->
      unless a.nodeName and c.noData[a.nodeName.toLowerCase()]
        a = (if a is A then za else a)
        d = a[G]
        f = c.cache
        e = f[d]
        if b
          if e
            delete e[b]

            c.isEmptyObject(e) and c.removeData(a)
        else
          if c.support.deleteExpando
            delete a[c.expando]
          else
            a.removeAttribute and a.removeAttribute(c.expando)
          delete f[d]

  c.fn.extend
    data: (a, b) ->
      if typeof a is "undefined" and @length
        return c.data(this[0])
      else if typeof a is "object"
        return @each(->
          c.data this, a
        )
      d = a.split(".")
      d[1] = (if d[1] then "." + d[1] else "")
      if b is w
        f = @triggerHandler("getData" + d[1] + "!", [d[0]])
        f = c.data(this[0], a)  if f is w and @length
        (if f is w and d[1] then @data(d[0]) else f)
      else
        @trigger("setData" + d[1] + "!", [d[0], b]).each ->
          c.data this, a, b


    removeData: (a) ->
      @each ->
        c.removeData this, a


  c.extend
    queue: (a, b, d) ->
      if a
        b = (b or "fx") + "queue"
        f = c.data(a, b)
        return f or []  unless d
        if not f or c.isArray(d)
          f = c.data(a, b, c.makeArray(d))
        else
          f.push d
        f

    dequeue: (a, b) ->
      b = b or "fx"
      d = c.queue(a, b)
      f = d.shift()
      f = d.shift()  if f is "inprogress"
      if f
        b is "fx" and d.unshift("inprogress")
        f.call a, ->
          c.dequeue a, b


  c.fn.extend
    queue: (a, b) ->
      if typeof a isnt "string"
        b = a
        a = "fx"
      return c.queue(this[0], a)  if b is w
      @each ->
        d = c.queue(this, a, b)
        a is "fx" and d[0] isnt "inprogress" and c.dequeue(this, a)


    dequeue: (a) ->
      @each ->
        c.dequeue this, a


    delay: (a, b) ->
      a = (if c.fx then c.fx.speeds[a] or a else a)
      b = b or "fx"
      @queue b, ->
        d = this
        setTimeout (->
          c.dequeue d, b
        ), a


    clearQueue: (a) ->
      @queue a or "fx", []

  Aa = /[\n\t]/g
  ca = /\s+/
  Za = /\r/g
  $a = /href|src|style/
  ab = /(button|input)/i
  bb = /(button|input|object|select|textarea)/i
  cb = /^(a|area)$/i
  Ba = /radio|checkbox/
  c.fn.extend
    attr: (a, b) ->
      X this, a, b, true, c.attr

    removeAttr: (a) ->
      @each ->
        c.attr this, a, ""
        @nodeType is 1 and @removeAttribute(a)


    addClass: (a) ->
      if c.isFunction(a)
        return @each((n) ->
          r = c(this)
          r.addClass a.call(this, n, r.attr("class"))
        )
      if a and typeof a is "string"
        b = (a or "").split(ca)
        d = 0
        f = @length

        while d < f
          e = this[d]
          if e.nodeType is 1
            if e.className
              j = " " + e.className + " "
              i = e.className
              o = 0
              k = b.length

              while o < k
                i += " " + b[o]  if j.indexOf(" " + b[o] + " ") < 0
                o++
              e.className = c.trim(i)
            else
              e.className = a
          d++
      this

    removeClass: (a) ->
      if c.isFunction(a)
        return @each((k) ->
          n = c(this)
          n.removeClass a.call(this, k, n.attr("class"))
        )
      if a and typeof a is "string" or a is w
        b = (a or "").split(ca)
        d = 0
        f = @length

        while d < f
          e = this[d]
          if e.nodeType is 1 and e.className
            if a
              j = (" " + e.className + " ").replace(Aa, " ")
              i = 0
              o = b.length

              while i < o
                j = j.replace(" " + b[i] + " ", " ")
                i++
              e.className = c.trim(j)
            else
              e.className = ""
          d++
      this

    toggleClass: (a, b) ->
      d = typeof a
      f = typeof b is "boolean"
      if c.isFunction(a)
        return @each((e) ->
          j = c(this)
          j.toggleClass a.call(this, e, j.attr("class"), b), b
        )
      @each ->
        if d is "string"
          e = undefined
          j = 0
          i = c(this)
          o = b
          k = a.split(ca)

          while e = k[j++]
            o = (if f then o else not i.hasClass(e))
            i[(if o then "addClass" else "removeClass")] e
        else if d is "undefined" or d is "boolean"
          @className and c.data(this, "__className__", @className)
          @className = (if @className or a is false then "" else c.data(this, "__className__") or "")


    hasClass: (a) ->
      a = " " + a + " "
      b = 0
      d = @length

      while b < d
        return true  if (" " + this[b].className + " ").replace(Aa, " ").indexOf(a) > -1
        b++
      false

    val: (a) ->
      if a is w
        b = this[0]
        if b
          return (if (b.attributes.value or {}).specified then b.value else b.text)  if c.nodeName(b, "option")
          if c.nodeName(b, "select")
            d = b.selectedIndex
            f = []
            e = b.options
            b = b.type is "select-one"
            return null  if d < 0
            j = (if b then d else 0)
            d = (if b then d + 1 else e.length)
            while j < d
              i = e[j]
              if i.selected
                a = c(i).val()
                return a  if b
                f.push a
              j++
            return f
          return (if b.getAttribute("value") is null then "on" else b.value)  if Ba.test(b.type) and not c.support.checkOn
          return (b.value or "").replace(Za, "")
        return w
      o = c.isFunction(a)
      @each (k) ->
        n = c(this)
        r = a
        if @nodeType is 1
          r = a.call(this, k, n.val())  if o
          r += ""  if typeof r is "number"
          if c.isArray(r) and Ba.test(@type)
            @checked = c.inArray(n.val(), r) >= 0
          else if c.nodeName(this, "select")
            u = c.makeArray(r)
            c("option", this).each ->
              @selected = c.inArray(c(this).val(), u) >= 0

            @selectedIndex = -1  unless u.length
          else
            @value = r


  c.extend
    attrFn:
      val: true
      css: true
      html: true
      text: true
      data: true
      width: true
      height: true
      offset: true

    attr: (a, b, d, f) ->
      return w  if not a or a.nodeType is 3 or a.nodeType is 8
      return c(a)[b](d)  if f and b of c.attrFn
      f = a.nodeType isnt 1 or not c.isXMLDoc(a)
      e = d isnt w
      b = f and c.props[b] or b
      if a.nodeType is 1
        j = $a.test(b)
        if b of a and f and not j
          if e
            b is "type" and ab.test(a.nodeName) and a.parentNode and c.error("type property can't be changed")
            a[b] = d
          return a.getAttributeNode(b).nodeValue  if c.nodeName(a, "form") and a.getAttributeNode(b)
          return (if (b = a.getAttributeNode("tabIndex")) and b.specified then b.value else (if bb.test(a.nodeName) or cb.test(a.nodeName) and a.href then 0 else w))  if b is "tabIndex"
          return a[b]
        if not c.support.style and f and b is "style"
          a.style.cssText = "" + d  if e
          return a.style.cssText
        e and a.setAttribute(b, "" + d)
        a = (if not c.support.hrefNormalized and f and j then a.getAttribute(b, 2) else a.getAttribute(b))
        return (if a is null then w else a)
      c.style a, b, d

  O = /\.(.*)$/
  db = (a) ->
    a.replace /[^\w\s\.\|`]/g, (b) ->
      "\\" + b


  c.event =
    add: (a, b, d, f) ->
      unless a.nodeType is 3 or a.nodeType is 8
        a = A  if a.setInterval and a isnt A and not a.frameElement
        e = undefined
        j = undefined
        if d.handler
          e = d
          d = e.handler
        d.guid = c.guid++  unless d.guid
        if j = c.data(a)
          i = j.events = j.events or {}
          o = j.handle
          unless o
            j.handle = o = ->
              (if typeof c isnt "undefined" and not c.event.triggered then c.event.handle.apply(o.elem, arguments_) else w)
          o.elem = a
          b = b.split(" ")
          k = undefined
          n = 0
          r = undefined

          while k = b[n++]
            j = (if e then c.extend({}, e) else
              handler: d
              data: f
            )
            if k.indexOf(".") > -1
              r = k.split(".")
              k = r.shift()
              j.namespace = r.slice(0).sort().join(".")
            else
              r = []
              j.namespace = ""
            j.type = k
            j.guid = d.guid
            u = i[k]
            z = c.event.special[k] or {}
            unless u
              u = i[k] = []
              if not z.setup or z.setup.call(a, f, r, o) is false
                if a.addEventListener
                  a.addEventListener k, o, false
                else
                  a.attachEvent and a.attachEvent("on" + k, o)
            if z.add
              z.add.call a, j
              j.handler.guid = d.guid  unless j.handler.guid
            u.push j
            c.event.global[k] = true
          a = null

    global: {}
    remove: (a, b, d, f) ->
      unless a.nodeType is 3 or a.nodeType is 8
        e = undefined
        j = 0
        i = undefined
        o = undefined
        k = undefined
        n = undefined
        r = undefined
        u = undefined
        z = c.data(a)
        C = z and z.events
        if z and C
          if b and b.type
            d = b.handler
            b = b.type
          if not b or typeof b is "string" and b.charAt(0) is "."
            b = b or ""
            for e of C
              c.event.remove a, e + b
          else
            b = b.split(" ")
            while e = b[j++]
              n = e
              i = e.indexOf(".") < 0
              o = []
              unless i
                o = e.split(".")
                e = o.shift()
                k = new RegExp("(^|\\.)" + c.map(o.slice(0).sort(), db).join("\\.(?:.*\\.)?") + "(\\.|$)")
              if r = C[e]
                if d
                  n = c.event.special[e] or {}
                  B = f or 0
                  while B < r.length
                    u = r[B]
                    if d.guid is u.guid
                      if i or k.test(u.namespace)
                        not f? and r.splice(B--, 1)
                        n.remove and n.remove.call(a, u)
                      break  if f?
                    B++
                  if r.length is 0 or f? and r.length is 1
                    Ca a, e, z.handle  if not n.teardown or n.teardown.call(a, o) is false
                    delete C[e]
                else
                  B = 0

                  while B < r.length
                    u = r[B]
                    if i or k.test(u.namespace)
                      c.event.remove a, n, u.handler, B
                      r.splice B--, 1
                    B++
            if c.isEmptyObject(C)
              b.elem = null  if b = z.handle
              delete z.events

              delete z.handle

              c.isEmptyObject(z) and c.removeData(a)

    trigger: (a, b, d, f) ->
      e = a.type or a
      unless f
        a = (if typeof a is "object" then (if a[G] then a else c.extend(c.Event(e), a)) else c.Event(e))
        if e.indexOf("!") >= 0
          a.type = e = e.slice(0, -1)
          a.exclusive = true
        unless d
          a.stopPropagation()
          c.event.global[e] and c.each(c.cache, ->
            @events and @events[e] and c.event.trigger(a, b, @handle.elem)
          )
        return w  if not d or d.nodeType is 3 or d.nodeType is 8
        a.result = w
        a.target = d
        b = c.makeArray(b)
        b.unshift a
      a.currentTarget = d
      (f = c.data(d, "handle")) and f.apply(d, b)
      f = d.parentNode or d.ownerDocument
      try
        a.result = false  if d["on" + e] and d["on" + e].apply(d, b) is false  unless d and d.nodeName and c.noData[d.nodeName.toLowerCase()]
      if not a.isPropagationStopped() and f
        c.event.trigger a, b, f, true
      else unless a.isDefaultPrevented()
        f = a.target
        i = undefined
        o = c.nodeName(f, "a") and e is "click"
        k = c.event.special[e] or {}
        if (not k._default or k._default.call(d, a) is false) and not o and not (f and f.nodeName and c.noData[f.nodeName.toLowerCase()])
          try
            if f[e]
              f["on" + e] = null  if i = f["on" + e]
              c.event.triggered = true
              f[e]()
          f["on" + e] = i  if i
          c.event.triggered = false

    handle: (a) ->
      b = undefined
      d = undefined
      f = undefined
      e = undefined
      a = arguments_[0] = c.event.fix(a or A.event)
      a.currentTarget = this
      b = a.type.indexOf(".") < 0 and not a.exclusive
      unless b
        d = a.type.split(".")
        a.type = d.shift()
        f = new RegExp("(^|\\.)" + d.slice(0).sort().join("\\.(?:.*\\.)?") + "(\\.|$)")
      e = c.data(this, "events")
      d = e[a.type]
      if e and d
        d = d.slice(0)
        e = 0
        j = d.length

        while e < j
          i = d[e]
          if b or f.test(i.namespace)
            a.handler = i.handler
            a.data = i.data
            a.handleObj = i
            i = i.handler.apply(this, arguments_)
            if i isnt w
              a.result = i
              if i is false
                a.preventDefault()
                a.stopPropagation()
            break  if a.isImmediatePropagationStopped()
          e++
      a.result

    props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" ")
    fix: (a) ->
      return a  if a[G]
      b = a
      a = c.Event(b)
      d = @props.length
      f = undefined

      while d
        f = @props[--d]
        a[f] = b[f]
      a.target = a.srcElement or s  unless a.target
      a.target = a.target.parentNode  if a.target.nodeType is 3
      a.relatedTarget = (if a.fromElement is a.target then a.toElement else a.fromElement)  if not a.relatedTarget and a.fromElement
      if not a.pageX? and a.clientX?
        b = s.documentElement
        d = s.body
        a.pageX = a.clientX + (b and b.scrollLeft or d and d.scrollLeft or 0) - (b and b.clientLeft or d and d.clientLeft or 0)
        a.pageY = a.clientY + (b and b.scrollTop or d and d.scrollTop or 0) - (b and b.clientTop or d and d.clientTop or 0)
      a.which = a.charCode or a.keyCode  if not a.which and ((if a.charCode or a.charCode is 0 then a.charCode else a.keyCode))
      a.metaKey = a.ctrlKey  if not a.metaKey and a.ctrlKey
      a.which = (if a.button & 1 then 1 else (if a.button & 2 then 3 else (if a.button & 4 then 2 else 0)))  if not a.which and a.button isnt w
      a

    guid: 1E8
    proxy: c.proxy
    special:
      ready:
        setup: c.bindReady
        teardown: c.noop

      live:
        add: (a) ->
          c.event.add this, a.origType, c.extend({}, a,
            handler: oa
          )

        remove: (a) ->
          b = true
          d = a.origType.replace(O, "")
          c.each c.data(this, "events").live or [], ->
            b = false  if d is @origType.replace(O, "")

          b and c.event.remove(this, a.origType, oa)

      beforeunload:
        setup: (a, b, d) ->
          @onbeforeunload = d  if @setInterval
          false

        teardown: (a, b) ->
          @onbeforeunload = null  if @onbeforeunload is b

  Ca = (if s.removeEventListener then (a, b, d) ->
    a.removeEventListener b, d, false
   else (a, b, d) ->
    a.detachEvent "on" + b, d
  )
  c.Event = (a) ->
    return new c.Event(a)  unless @preventDefault
    if a and a.type
      @originalEvent = a
      @type = a.type
    else
      @type = a
    @timeStamp = J()
    this[G] = true

  c.Event:: =
    preventDefault: ->
      @isDefaultPrevented = Z
      a = @originalEvent
      if a
        a.preventDefault and a.preventDefault()
        a.returnValue = false

    stopPropagation: ->
      @isPropagationStopped = Z
      a = @originalEvent
      if a
        a.stopPropagation and a.stopPropagation()
        a.cancelBubble = true

    stopImmediatePropagation: ->
      @isImmediatePropagationStopped = Z
      @stopPropagation()

    isDefaultPrevented: Y
    isPropagationStopped: Y
    isImmediatePropagationStopped: Y

  Da = (a) ->
    b = a.relatedTarget
    try
      while b and b isnt this
        b = b.parentNode
      if b isnt this
        a.type = a.data
        c.event.handle.apply this, arguments_

  Ea = (a) ->
    a.type = a.data
    c.event.handle.apply this, arguments_

  c.each
    mouseenter: "mouseover"
    mouseleave: "mouseout"
  , (a, b) ->
    c.event.special[a] =
      setup: (d) ->
        c.event.add this, b, (if d and d.selector then Ea else Da), a

      teardown: (d) ->
        c.event.remove this, b, (if d and d.selector then Ea else Da)

  unless c.support.submitBubbles
    c.event.special.submit =
      setup: ->
        if @nodeName.toLowerCase() isnt "form"
          c.event.add this, "click.specialSubmit", (a) ->
            b = a.target
            d = b.type
            na "submit", this, arguments_  if (d is "submit" or d is "image") and c(b).closest("form").length

          c.event.add this, "keypress.specialSubmit", (a) ->
            b = a.target
            d = b.type
            na "submit", this, arguments_  if (d is "text" or d is "password") and c(b).closest("form").length and a.keyCode is 13

        else
          false

      teardown: ->
        c.event.remove this, ".specialSubmit"
  unless c.support.changeBubbles
    da = /textarea|input|select/i
    ea = undefined
    Fa = (a) ->
      b = a.type
      d = a.value
      if b is "radio" or b is "checkbox"
        d = a.checked
      else if b is "select-multiple"
        d = (if a.selectedIndex > -1 then c.map(a.options, (f) ->
          f.selected
        ).join("-") else "")
      else d = a.selectedIndex  if a.nodeName.toLowerCase() is "select"
      d

    fa = (a, b) ->
      d = a.target
      f = undefined
      e = undefined
      unless not da.test(d.nodeName) or d.readOnly
        f = c.data(d, "_change_data")
        e = Fa(d)
        c.data d, "_change_data", e  if a.type isnt "focusout" or d.type isnt "radio"
        unless f is w or e is f
          if f? or e
            a.type = "change"
            c.event.trigger a, b, d

    c.event.special.change =
      filters:
        focusout: fa
        click: (a) ->
          b = a.target
          d = b.type
          fa.call this, a  if d is "radio" or d is "checkbox" or b.nodeName.toLowerCase() is "select"

        keydown: (a) ->
          b = a.target
          d = b.type
          fa.call this, a  if a.keyCode is 13 and b.nodeName.toLowerCase() isnt "textarea" or a.keyCode is 32 and (d is "checkbox" or d is "radio") or d is "select-multiple"

        beforeactivate: (a) ->
          a = a.target
          c.data a, "_change_data", Fa(a)

      setup: ->
        return false  if @type is "file"
        for a of ea
          c.event.add this, a + ".specialChange", ea[a]
        da.test @nodeName

      teardown: ->
        c.event.remove this, ".specialChange"
        da.test @nodeName

    ea = c.event.special.change.filters
  s.addEventListener and c.each(
    focus: "focusin"
    blur: "focusout"
  , (a, b) ->
    d = (f) ->
      f = c.event.fix(f)
      f.type = b
      c.event.handle.call this, f
    c.event.special[b] =
      setup: ->
        @addEventListener a, d, true

      teardown: ->
        @removeEventListener a, d, true
  )
  c.each ["bind", "one"], (a, b) ->
    c.fn[b] = (d, f, e) ->
      if typeof d is "object"
        for j of d
          this[b] j, f, d[j], e
        return this
      if c.isFunction(f)
        e = f
        f = w
      i = (if b is "one" then c.proxy(e, (k) ->
        c(this).unbind k, i
        e.apply this, arguments_
      ) else e)
      unless d is "unload" and b isnt "one"
        j = 0
        o = @length

        while j < o
          c.event.add this[j], d, i, f
          j++
      this

  c.fn.extend
    unbind: (a, b) ->
      unless typeof a is "object" and not a.preventDefault
        d = 0
        f = @length

        while d < f
          c.event.remove this[d], a, b
          d++
      this

    delegate: (a, b, d, f) ->
      @live b, d, f, a

    undelegate: (a, b, d) ->
      (if arguments_.length is 0 then @unbind("live") else @die(b, null, d, a))

    trigger: (a, b) ->
      @each ->
        c.event.trigger a, b, this


    triggerHandler: (a, b) ->
      if this[0]
        a = c.Event(a)
        a.preventDefault()
        a.stopPropagation()
        c.event.trigger a, b, this[0]
        a.result

    toggle: (a) ->
      b = arguments_
      d = 1

      while d < b.length
        c.proxy a, b[d++]
      @click c.proxy(a, (f) ->
        e = (c.data(this, "lastToggle" + a.guid) or 0) % d
        c.data this, "lastToggle" + a.guid, e + 1
        f.preventDefault()
        b[e].apply(this, arguments_) or false
      )

    hover: (a, b) ->
      @mouseenter(a).mouseleave b or a

  Ga =
    focus: "focusin"
    blur: "focusout"
    mouseenter: "mouseover"
    mouseleave: "mouseout"

  c.each ["live", "die"], (a, b) ->
    c.fn[b] = (d, f, e, j) ->
      i = undefined
      o = 0
      k = undefined
      n = undefined
      r = j or @selector
      u = (if j then this else c(@context))
      if c.isFunction(f)
        e = f
        f = w
      d = (d or "").split(" ")
      while (i = d[o++])?
        j = O.exec(i)
        k = ""
        if j
          k = j[0]
          i = i.replace(O, "")
        unless i is "hover"
          n = i
          if i is "focus" or i is "blur"
            d.push Ga[i] + k
            i += k
          else
            i = (Ga[i] or i) + k
          (if b is "live" then u.each(->
            c.event.add this, pa(i, r),
              data: f
              selector: r
              handler: e
              origType: i
              origHandler: e
              preType: n

          ) else u.unbind(pa(i, r), e))
      this

  c.each "blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "), (a, b) ->
    c.fn[b] = (d) ->
      (if d then @bind(b, d) else @trigger(b))

    c.attrFn[b] = true  if c.attrFn

  A.attachEvent and not A.addEventListener and A.attachEvent("onunload", ->
    for a of c.cache
      if c.cache[a].handle
        try
          c.event.remove c.cache[a].handle.elem
  )
  (->
    a = (g) ->
      h = ""
      l = undefined
      m = 0

      while g[m]
        l = g[m]
        if l.nodeType is 3 or l.nodeType is 4
          h += l.nodeValue
        else h += a(l.childNodes)  if l.nodeType isnt 8
        m++
      h
    b = (g, h, l, m, q, p) ->
      q = 0
      v = m.length

      while q < v
        t = m[q]
        if t
          t = t[g]
          y = false

          while t
            if t.sizcache is l
              y = m[t.sizset]
              break
            if t.nodeType is 1 and not p
              t.sizcache = l
              t.sizset = q
            if t.nodeName.toLowerCase() is h
              y = t
              break
            t = t[g]
          m[q] = y
        q++
    d = (g, h, l, m, q, p) ->
      q = 0
      v = m.length

      while q < v
        t = m[q]
        if t
          t = t[g]
          y = false

          while t
            if t.sizcache is l
              y = m[t.sizset]
              break
            if t.nodeType is 1
              unless p
                t.sizcache = l
                t.sizset = q
              if typeof h isnt "string"
                if t is h
                  y = true
                  break
              else if k.filter(h, [t]).length > 0
                y = t
                break
            t = t[g]
          m[q] = y
        q++
    f = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g
    e = 0
    j = Object::toString
    i = false
    o = true
    [0, 0].sort ->
      o = false
      0

    k = (g, h, l, m) ->
      l = l or []
      q = h = h or s
      return []  if h.nodeType isnt 1 and h.nodeType isnt 9
      return l  if not g or typeof g isnt "string"
      p = []
      v = undefined
      t = undefined
      y = undefined
      S = undefined
      H = true
      M = x(h)
      I = g

      while (f.exec("")
      v = f.exec(I)
      ) isnt null
        I = v[3]
        p.push v[1]
        if v[2]
          S = v[3]
          break
      unless p.length > 1 and r.exec(g)
        if not m and p.length > 1 and h.nodeType is 9 and not M and n.match.ID.test(p[0]) and not n.match.ID.test(p[p.length - 1])
          v = k.find(p.shift(), h, M)
          h = (if v.expr then k.filter(v.expr, v.set)[0] else v.set[0])
        if h
          v = (if m then
            expr: p.pop()
            set: z(m)
           else k.find(p.pop(), (if p.length is 1 and (p[0] is "~" or p[0] is "+") and h.parentNode then h.parentNode else h), M))
          t = (if v.expr then k.filter(v.expr, v.set) else v.set)
          if p.length > 0
            y = z(t)
          else
            H = false
          while p.length
            D = p.pop()
            v = D
            if n.relative[D]
              v = p.pop()
            else
              D = ""
            v = h  unless v?
            n.relative[D] y, v, M
        else
          y = []
      y or (y = t)
      y or k.error(D or g)
      if j.call(y) is "[object Array]"
        if H
          if h and h.nodeType is 1
            g = 0
            while y[g]?
              l.push t[g]  if y[g] and (y[g] is true or y[g].nodeType is 1 and E(h, y[g]))
              g++
          else
            g = 0
            while y[g]?
              y[g] and y[g].nodeType is 1 and l.push(t[g])
              g++
        else
          l.push.apply l, y
      else
        z y, l
      if S
        k S, q, l, m
        k.uniqueSort l
      l

    k.uniqueSort = (g) ->
      if B
        i = o
        g.sort B
        if i
          h = 1

          while h < g.length
            g[h] is g[h - 1] and g.splice(h--, 1)
            h++
      g

    k.matches = (g, h) ->
      k g, null, null, h

    k.find = (g, h, l) ->
      m = undefined
      q = undefined
      return []  unless g
      p = 0
      v = n.order.length

      while p < v
        t = n.order[p]
        if q = n.leftMatch[t].exec(g)
          y = q[1]
          q.splice 1, 1
          if y.substr(y.length - 1) isnt "\\"
            q[1] = (q[1] or "").replace(/\\/g, "")
            m = n.find[t](q, h, l)
            if m?
              g = g.replace(n.match[t], "")
              break
        p++
      m or (m = h.getElementsByTagName("*"))
      set: m
      expr: g

    k.filter = (g, h, l, m) ->
      q = g
      p = []
      v = h
      t = undefined
      y = undefined
      S = h and h[0] and x(h[0])

      while g and h.length
        for H of n.filter
          if (t = n.leftMatch[H].exec(g))? and t[2]
            M = n.filter[H]
            I = undefined
            D = undefined
            D = t[1]
            y = false
            t.splice 1, 1
            if D.substr(D.length - 1) isnt "\\"
              p = []  if v is p
              if n.preFilter[H]
                if t = n.preFilter[H](t, v, l, p, m, S)
                  continue  if t is true
                else
                  y = I = true
              if t
                U = 0

                while (D = v[U])?
                  if D
                    I = M(D, t, U, v)
                    Ha = m ^ !!I
                    if l and I?
                      if Ha
                        y = true
                      else
                        v[U] = false
                    else if Ha
                      p.push D
                      y = true
                  U++
              if I isnt w
                l or (v = p)
                g = g.replace(n.match[H], "")
                return []  unless y
                break
        if g is q
          unless y?
            k.error g
          else
            break
        q = g
      v

    k.error = (g) ->
      throw "Syntax error, unrecognized expression: " + g

    n = k.selectors =
      order: ["ID", "NAME", "TAG"]
      match:
        ID: /#((?:[\w\u00c0-\uFFFF-]|\\.)+)/
        CLASS: /\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/
        NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/
        ATTR: /\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/
        TAG: /^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/
        CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/
        POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/
        PSEUDO: /:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/

      leftMatch: {}
      attrMap:
        class: "className"
        for: "htmlFor"

      attrHandle:
        href: (g) ->
          g.getAttribute "href"

      relative:
        "+": (g, h) ->
          l = typeof h is "string"
          m = l and not /\W/.test(h)
          l = l and not m
          h = h.toLowerCase()  if m
          m = 0
          q = g.length
          p = undefined

          while m < q
            if p = g[m]
              while (p = p.previousSibling) and p.nodeType isnt 1

              g[m] = (if l or p and p.nodeName.toLowerCase() is h then p or false else p is h)
            m++
          l and k.filter(h, g, true)

        ">": (g, h) ->
          l = typeof h is "string"
          if l and not /\W/.test(h)
            h = h.toLowerCase()
            m = 0
            q = g.length

            while m < q
              p = g[m]
              if p
                l = p.parentNode
                g[m] = (if l.nodeName.toLowerCase() is h then l else false)
              m++
          else
            m = 0
            q = g.length
            while m < q
              g[m] = (if l then p.parentNode else p.parentNode is h)  if p = g[m]
              m++
            l and k.filter(h, g, true)

        "": (g, h, l) ->
          m = e++
          q = d
          if typeof h is "string" and not /\W/.test(h)
            p = h = h.toLowerCase()
            q = b
          q "parentNode", h, m, g, p, l

        "~": (g, h, l) ->
          m = e++
          q = d
          if typeof h is "string" and not /\W/.test(h)
            p = h = h.toLowerCase()
            q = b
          q "previousSibling", h, m, g, p, l

      find:
        ID: (g, h, l) ->
          (if (g = h.getElementById(g[1])) then [g] else [])  if typeof h.getElementById isnt "undefined" and not l

        NAME: (g, h) ->
          if typeof h.getElementsByName isnt "undefined"
            l = []
            h = h.getElementsByName(g[1])
            m = 0
            q = h.length

            while m < q
              h[m].getAttribute("name") is g[1] and l.push(h[m])
              m++
            (if l.length is 0 then null else l)

        TAG: (g, h) ->
          h.getElementsByTagName g[1]

      preFilter:
        CLASS: (g, h, l, m, q, p) ->
          g = " " + g[1].replace(/\\/g, "") + " "
          return g  if p
          p = 0
          v = undefined

          while (v = h[p])?
            if v
              if q ^ (v.className and (" " + v.className + " ").replace(/[\t\n]/g, " ").indexOf(g) >= 0)
                l or m.push(v)
              else h[p] = false  if l
            p++
          false

        ID: (g) ->
          g[1].replace /\\/g, ""

        TAG: (g) ->
          g[1].toLowerCase()

        CHILD: (g) ->
          if g[1] is "nth"
            h = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2] is "even" and "2n" or g[2] is "odd" and "2n+1" or not /\D/.test(g[2]) and "0n+" + g[2] or g[2])
            g[2] = h[1] + (h[2] or 1) - 0
            g[3] = h[3] - 0
          g[0] = e++
          g

        ATTR: (g, h, l, m, q, p) ->
          h = g[1].replace(/\\/g, "")
          g[1] = n.attrMap[h]  if not p and n.attrMap[h]
          g[4] = " " + g[4] + " "  if g[2] is "~="
          g

        PSEUDO: (g, h, l, m, q) ->
          if g[1] is "not"
            unless (f.exec(g[3]) or "").length > 1 or /^\w/.test(g[3])
              g = k.filter(g[3], h, l, true ^ q)
              l or m.push.apply(m, g)
              return false
          else return true  if n.match.POS.test(g[0]) or n.match.CHILD.test(g[0])
          g

        POS: (g) ->
          g.unshift true
          g

      filters:
        enabled: (g) ->
          g.disabled is false and g.type isnt "hidden"

        disabled: (g) ->
          g.disabled is true

        checked: (g) ->
          g.checked is true

        selected: (g) ->
          g.selected is true

        parent: (g) ->
          !!g.firstChild

        empty: (g) ->
          not g.firstChild

        has: (g, h, l) ->
          !!k(l[3], g).length

        header: (g) ->
          /h\d/i.test g.nodeName

        text: (g) ->
          "text" is g.type

        radio: (g) ->
          "radio" is g.type

        checkbox: (g) ->
          "checkbox" is g.type

        file: (g) ->
          "file" is g.type

        password: (g) ->
          "password" is g.type

        submit: (g) ->
          "submit" is g.type

        image: (g) ->
          "image" is g.type

        reset: (g) ->
          "reset" is g.type

        button: (g) ->
          "button" is g.type or g.nodeName.toLowerCase() is "button"

        input: (g) ->
          /input|select|textarea|button/i.test g.nodeName

      setFilters:
        first: (g, h) ->
          h is 0

        last: (g, h, l, m) ->
          h is m.length - 1

        even: (g, h) ->
          h % 2 is 0

        odd: (g, h) ->
          h % 2 is 1

        lt: (g, h, l) ->
          h < l[3] - 0

        gt: (g, h, l) ->
          h > l[3] - 0

        nth: (g, h, l) ->
          l[3] - 0 is h

        eq: (g, h, l) ->
          l[3] - 0 is h

      filter:
        PSEUDO: (g, h, l, m) ->
          q = h[1]
          p = n.filters[q]
          if p
            p g, l, h, m
          else if q is "contains"
            (g.textContent or g.innerText or a([g]) or "").indexOf(h[3]) >= 0
          else if q is "not"
            h = h[3]
            l = 0
            m = h.length
            while l < m
              return false  if h[l] is g
              l++
            true
          else
            k.error "Syntax error, unrecognized expression: " + q

        CHILD: (g, h) ->
          l = h[1]
          m = g
          switch l
            when "only", "first"
              while m = m.previousSibling
                return false  if m.nodeType is 1
              return true  if l is "first"
              m = g
            when "last"
              while m = m.nextSibling
                return false  if m.nodeType is 1
              true
            when "nth"
              l = h[2]
              q = h[3]
              return true  if l is 1 and q is 0
              h = h[0]
              p = g.parentNode
              if p and (p.sizcache isnt h or not g.nodeIndex)
                v = 0
                m = p.firstChild
                while m
                  m.nodeIndex = ++v  if m.nodeType is 1
                  m = m.nextSibling
                p.sizcache = h
              g = g.nodeIndex - q
              (if l is 0 then g is 0 else g % l is 0 and g / l >= 0)

        ID: (g, h) ->
          g.nodeType is 1 and g.getAttribute("id") is h

        TAG: (g, h) ->
          h is "*" and g.nodeType is 1 or g.nodeName.toLowerCase() is h

        CLASS: (g, h) ->
          (" " + (g.className or g.getAttribute("class")) + " ").indexOf(h) > -1

        ATTR: (g, h) ->
          l = h[1]
          g = (if n.attrHandle[l] then n.attrHandle[l](g) else (if g[l]? then g[l] else g.getAttribute(l)))
          l = g + ""
          m = h[2]
          h = h[4]
          (if not g? then m is "!=" else (if m is "=" then l is h else (if m is "*=" then l.indexOf(h) >= 0 else (if m is "~=" then (" " + l + " ").indexOf(h) >= 0 else (if not h then l and g isnt false else (if m is "!=" then l isnt h else (if m is "^=" then l.indexOf(h) is 0 else (if m is "$=" then l.substr(l.length - h.length) is h else (if m is "|=" then l is h or l.substr(0, h.length + 1) is h + "-" else false)))))))))

        POS: (g, h, l, m) ->
          q = n.setFilters[h[2]]
          q g, l, h, m  if q

    r = n.match.POS
    for u of n.match
      n.match[u] = new RegExp(n.match[u].source + /(?![^\[]*\])(?![^\(]*\))/.source)
      n.leftMatch[u] = new RegExp(/(^(?:.|\r|\n)*?)/.source + n.match[u].source.replace(/\\(\d+)/g, (g, h) ->
        "\\" + (h - 0 + 1)
      ))
    z = (g, h) ->
      g = Array::slice.call(g, 0)
      if h
        h.push.apply h, g
        return h
      g

    try
      Array::slice.call s.documentElement.childNodes, 0
    catch C
      z = (g, h) ->
        h = h or []
        if j.call(g) is "[object Array]"
          Array::push.apply h, g
        else if typeof g.length is "number"
          l = 0
          m = g.length

          while l < m
            h.push g[l]
            l++
        else
          l = 0
          while g[l]
            h.push g[l]
            l++
        h
    B = undefined
    if s.documentElement.compareDocumentPosition
      B = (g, h) ->
        if not g.compareDocumentPosition or not h.compareDocumentPosition
          i = true  if g is h
          return (if g.compareDocumentPosition then -1 else 1)
        g = (if g.compareDocumentPosition(h) & 4 then -1 else (if g is h then 0 else 1))
        i = true  if g is 0
        g
    else if "sourceIndex" of s.documentElement
      B = (g, h) ->
        if not g.sourceIndex or not h.sourceIndex
          i = true  if g is h
          return (if g.sourceIndex then -1 else 1)
        g = g.sourceIndex - h.sourceIndex
        i = true  if g is 0
        g
    else if s.createRange
      B = (g, h) ->
        if not g.ownerDocument or not h.ownerDocument
          i = true  if g is h
          return (if g.ownerDocument then -1 else 1)
        l = g.ownerDocument.createRange()
        m = h.ownerDocument.createRange()
        l.setStart g, 0
        l.setEnd g, 0
        m.setStart h, 0
        m.setEnd h, 0
        g = l.compareBoundaryPoints(Range.START_TO_END, m)
        i = true  if g is 0
        g
    (->
      g = s.createElement("div")
      h = "script" + (new Date).getTime()
      g.innerHTML = "<a name='" + h + "'/>"
      l = s.documentElement
      l.insertBefore g, l.firstChild
      if s.getElementById(h)
        n.find.ID = (m, q, p) ->
          (if (q = q.getElementById(m[1])) then (if q.id is m[1] or typeof q.getAttributeNode isnt "undefined" and q.getAttributeNode("id").nodeValue is m[1] then [q] else w) else [])  if typeof q.getElementById isnt "undefined" and not p

        n.filter.ID = (m, q) ->
          p = typeof m.getAttributeNode isnt "undefined" and m.getAttributeNode("id")
          m.nodeType is 1 and p and p.nodeValue is q
      l.removeChild g
      l = g = null
    )()
    (->
      g = s.createElement("div")
      g.appendChild s.createComment("")
      if g.getElementsByTagName("*").length > 0
        n.find.TAG = (h, l) ->
          l = l.getElementsByTagName(h[1])
          if h[1] is "*"
            h = []
            m = 0

            while l[m]
              l[m].nodeType is 1 and h.push(l[m])
              m++
            l = h
          l
      g.innerHTML = "<a href='#'></a>"
      if g.firstChild and typeof g.firstChild.getAttribute isnt "undefined" and g.firstChild.getAttribute("href") isnt "#"
        n.attrHandle.href = (h) ->
          h.getAttribute "href", 2
      g = null
    )()
    s.querySelectorAll and ->
      g = k
      h = s.createElement("div")
      h.innerHTML = "<p class='TEST'></p>"
      unless h.querySelectorAll and h.querySelectorAll(".TEST").length is 0
        k = (m, q, p, v) ->
          q = q or s
          if not v and q.nodeType is 9 and not x(q)
            try
              return z(q.querySelectorAll(m), p)
          g m, q, p, v

        for l of g
          k[l] = g[l]
        h = null
    ()
    (->
      g = s.createElement("div")
      g.innerHTML = "<div class='test e'></div><div class='test'></div>"
      unless not g.getElementsByClassName or g.getElementsByClassName("e").length is 0
        g.lastChild.className = "e"
        if g.getElementsByClassName("e").length isnt 1
          n.order.splice 1, 0, "CLASS"
          n.find.CLASS = (h, l, m) ->
            l.getElementsByClassName h[1]  if typeof l.getElementsByClassName isnt "undefined" and not m

          g = null
    )()
    E = (if s.compareDocumentPosition then (g, h) ->
      !!(g.compareDocumentPosition(h) & 16)
     else (g, h) ->
      g isnt h and ((if g.contains then g.contains(h) else true))
    )
    x = (g) ->
      (if (g = ((if g then g.ownerDocument or g else 0)).documentElement) then g.nodeName isnt "HTML" else false)

    ga = (g, h) ->
      l = []
      m = ""
      q = undefined
      h = (if h.nodeType then [h] else h)
      while q = n.match.PSEUDO.exec(g)
        m += q[0]
        g = g.replace(n.match.PSEUDO, "")
      g = (if n.relative[g] then g + "*" else g)
      q = 0
      p = h.length

      while q < p
        k g, h[q], l
        q++
      k.filter m, l

    c.find = k
    c.expr = k.selectors
    c.expr[":"] = c.expr.filters
    c.unique = k.uniqueSort
    c.text = a
    c.isXMLDoc = x
    c.contains = E
  )()
  eb = /Until$/
  fb = /^(?:parents|prevUntil|prevAll)/
  gb = /,/
  R = Array::slice
  Ia = (a, b, d) ->
    if c.isFunction(b)
      return c.grep(a, (e, j) ->
        !!b.call(e, j, e) is d
      )
    else if b.nodeType
      return c.grep(a, (e) ->
        e is b is d
      )
    else if typeof b is "string"
      f = c.grep(a, (e) ->
        e.nodeType is 1
      )
      if Ua.test(b)
        return c.filter(b, f, not d)
      else
        b = c.filter(b, f)
    c.grep a, (e) ->
      c.inArray(e, b) >= 0 is d


  c.fn.extend
    find: (a) ->
      b = @pushStack("", "find", a)
      d = 0
      f = 0
      e = @length

      while f < e
        d = b.length
        c.find a, this[f], b
        if f > 0
          j = d

          while j < b.length
            i = 0

            while i < d
              if b[i] is b[j]
                b.splice j--, 1
                break
              i++
            j++
        f++
      b

    has: (a) ->
      b = c(a)
      @filter ->
        d = 0
        f = b.length

        while d < f
          return true  if c.contains(this, b[d])
          d++


    not: (a) ->
      @pushStack Ia(this, a, false), "not", a

    filter: (a) ->
      @pushStack Ia(this, a, true), "filter", a

    is: (a) ->
      !!a and c.filter(a, this).length > 0

    closest: (a, b) ->
      if c.isArray(a)
        d = []
        f = this[0]
        e = undefined
        j = {}
        i = undefined
        if f and a.length
          e = 0
          o = a.length

          while e < o
            i = a[e]
            j[i] or (j[i] = (if c.expr.match.POS.test(i) then c(i, b or @context) else i))
            e++
          while f and f.ownerDocument and f isnt b
            for i of j
              e = j[i]
              if (if e.jquery then e.index(f) > -1 else c(f).is(e))
                d.push
                  selector: i
                  elem: f

                delete j[i]
            f = f.parentNode
        return d
      k = (if c.expr.match.POS.test(a) then c(a, b or @context) else null)
      @map (n, r) ->
        while r and r.ownerDocument and r isnt b
          return r  if (if k then k.index(r) > -1 else c(r).is(a))
          r = r.parentNode
        null


    index: (a) ->
      return c.inArray(this[0], (if a then c(a) else @parent().children()))  if not a or typeof a is "string"
      c.inArray (if a.jquery then a[0] else a), this

    add: (a, b) ->
      a = (if typeof a is "string" then c(a, b or @context) else c.makeArray(a))
      b = c.merge(@get(), a)
      @pushStack (if qa(a[0]) or qa(b[0]) then b else c.unique(b))

    andSelf: ->
      @add @prevObject

  c.each
    parent: (a) ->
      (if (a = a.parentNode) and a.nodeType isnt 11 then a else null)

    parents: (a) ->
      c.dir a, "parentNode"

    parentsUntil: (a, b, d) ->
      c.dir a, "parentNode", d

    next: (a) ->
      c.nth a, 2, "nextSibling"

    prev: (a) ->
      c.nth a, 2, "previousSibling"

    nextAll: (a) ->
      c.dir a, "nextSibling"

    prevAll: (a) ->
      c.dir a, "previousSibling"

    nextUntil: (a, b, d) ->
      c.dir a, "nextSibling", d

    prevUntil: (a, b, d) ->
      c.dir a, "previousSibling", d

    siblings: (a) ->
      c.sibling a.parentNode.firstChild, a

    children: (a) ->
      c.sibling a.firstChild

    contents: (a) ->
      (if c.nodeName(a, "iframe") then a.contentDocument or a.contentWindow.document else c.makeArray(a.childNodes))
  , (a, b) ->
    c.fn[a] = (d, f) ->
      e = c.map(this, b, d)
      eb.test(a) or (f = d)
      e = c.filter(f, e)  if f and typeof f is "string"
      e = (if @length > 1 then c.unique(e) else e)
      e = e.reverse()  if (@length > 1 or gb.test(f)) and fb.test(a)
      @pushStack e, a, R.call(arguments_).join(",")

  c.extend
    filter: (a, b, d) ->
      a = ":not(" + a + ")"  if d
      c.find.matches a, b

    dir: (a, b, d) ->
      f = []
      a = a[b]
      while a and a.nodeType isnt 9 and (d is w or a.nodeType isnt 1 or not c(a).is(d))
        a.nodeType is 1 and f.push(a)
        a = a[b]
      f

    nth: (a, b, d) ->
      b = b or 1
      f = 0

      while a
        break  if a.nodeType is 1 and ++f is b
        a = a[d]
      a

    sibling: (a, b) ->
      d = []

      while a
        a.nodeType is 1 and a isnt b and d.push(a)
        a = a.nextSibling
      d

  Ja = RegExp(" jQuery\\d+=\"(?:\\d+|null)\"", "g")
  V = /^\s+/
  Ka = /(<([\w:]+)[^>]*?)\/>/g
  hb = /^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i
  La = /<([\w:]+)/
  ib = /<tbody/i
  jb = /<|&#?\w+;/
  ta = /<script|<object|<embed|<option|<style/i
  ua = /checked\s*(?:[^=]|=\s*.checked.)/i
  Ma = (a, b, d) ->
    (if hb.test(d) then a else b + "></" + d + ">")

  F =
    option: [1, "<select multiple='multiple'>", "</select>"]
    legend: [1, "<fieldset>", "</fieldset>"]
    thead: [1, "<table>", "</table>"]
    tr: [2, "<table><tbody>", "</tbody></table>"]
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"]
    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"]
    area: [1, "<map>", "</map>"]
    _default: [0, "", ""]

  F.optgroup = F.option
  F.tbody = F.tfoot = F.colgroup = F.caption = F.thead
  F.th = F.td
  F._default = [1, "div<div>", "</div>"]  unless c.support.htmlSerialize
  c.fn.extend
    text: (a) ->
      if c.isFunction(a)
        return @each((b) ->
          d = c(this)
          d.text a.call(this, b, d.text())
        )
      return @empty().append((this[0] and this[0].ownerDocument or s).createTextNode(a))  if typeof a isnt "object" and a isnt w
      c.text this

    wrapAll: (a) ->
      if c.isFunction(a)
        return @each((d) ->
          c(this).wrapAll a.call(this, d)
        )
      if this[0]
        b = c(a, this[0].ownerDocument).eq(0).clone(true)
        this[0].parentNode and b.insertBefore(this[0])
        b.map(->
          d = this

          while d.firstChild and d.firstChild.nodeType is 1
            d = d.firstChild
          d
        ).append this
      this

    wrapInner: (a) ->
      if c.isFunction(a)
        return @each((b) ->
          c(this).wrapInner a.call(this, b)
        )
      @each ->
        b = c(this)
        d = b.contents()
        (if d.length then d.wrapAll(a) else b.append(a))


    wrap: (a) ->
      @each ->
        c(this).wrapAll a


    unwrap: ->
      @parent().each(->
        c.nodeName(this, "body") or c(this).replaceWith(@childNodes)
      ).end()

    append: ->
      @domManip arguments_, true, (a) ->
        @nodeType is 1 and @appendChild(a)


    prepend: ->
      @domManip arguments_, true, (a) ->
        @nodeType is 1 and @insertBefore(a, @firstChild)


    before: ->
      if this[0] and this[0].parentNode
        @domManip arguments_, false, (b) ->
          @parentNode.insertBefore b, this

      else if arguments_.length
        a = c(arguments_[0])
        a.push.apply a, @toArray()
        @pushStack a, "before", arguments_

    after: ->
      if this[0] and this[0].parentNode
        @domManip arguments_, false, (b) ->
          @parentNode.insertBefore b, @nextSibling

      else if arguments_.length
        a = @pushStack(this, "after", arguments_)
        a.push.apply a, c(arguments_[0]).toArray()
        a

    remove: (a, b) ->
      d = 0
      f = undefined

      while (f = this[d])?
        if not a or c.filter(a, [f]).length
          if not b and f.nodeType is 1
            c.cleanData f.getElementsByTagName("*")
            c.cleanData [f]
          f.parentNode and f.parentNode.removeChild(f)
        d++
      this

    empty: ->
      a = 0
      b = undefined

      while (b = this[a])?
        b.nodeType is 1 and c.cleanData(b.getElementsByTagName("*"))
        while b.firstChild
          b.removeChild b.firstChild
        a++
      this

    clone: (a) ->
      b = @map(->
        if not c.support.noCloneEvent and not c.isXMLDoc(this)
          d = @outerHTML
          f = @ownerDocument
          unless d
            d = f.createElement("div")
            d.appendChild @cloneNode(true)
            d = d.innerHTML
          c.clean([d.replace(Ja, "").replace(RegExp("=([^=\"'>\\s]+\\/)>", "g"), "=\"$1\">").replace(V, "")], f)[0]
        else
          @cloneNode true
      )
      if a is true
        ra this, b
        ra @find("*"), b.find("*")
      b

    html: (a) ->
      if a is w
        return (if this[0] and this[0].nodeType is 1 then this[0].innerHTML.replace(Ja, "") else null)
      else if typeof a is "string" and not ta.test(a) and (c.support.leadingWhitespace or not V.test(a)) and not F[(La.exec(a) or ["", ""])[1].toLowerCase()]
        a = a.replace(Ka, Ma)
        try
          b = 0
          d = @length

          while b < d
            if this[b].nodeType is 1
              c.cleanData this[b].getElementsByTagName("*")
              this[b].innerHTML = a
            b++
        catch f
          @empty().append a
      else
        (if c.isFunction(a) then @each((e) ->
          j = c(this)
          i = j.html()
          j.empty().append ->
            a.call this, e, i

        ) else @empty().append(a))
      this

    replaceWith: (a) ->
      if this[0] and this[0].parentNode
        if c.isFunction(a)
          return @each((b) ->
            d = c(this)
            f = d.html()
            d.replaceWith a.call(this, b, f)
          )
        a = c(a).detach()  if typeof a isnt "string"
        @each ->
          b = @nextSibling
          d = @parentNode
          c(this).remove()
          (if b then c(b).before(a) else c(d).append(a))

      else
        @pushStack c((if c.isFunction(a) then a() else a)), "replaceWith", a

    detach: (a) ->
      @remove a, true

    domManip: (a, b, d) ->
      f = (u) ->
        (if c.nodeName(u, "table") then u.getElementsByTagName("tbody")[0] or u.appendChild(u.ownerDocument.createElement("tbody")) else u)
      e = undefined
      j = undefined
      i = a[0]
      o = []
      k = undefined
      if not c.support.checkClone and arguments_.length is 3 and typeof i is "string" and ua.test(i)
        return @each(->
          c(this).domManip a, b, d, true
        )
      if c.isFunction(i)
        return @each((u) ->
          z = c(this)
          a[0] = i.call(this, u, (if b then z.html() else w))
          z.domManip a, b, d
        )
      if this[0]
        e = i and i.parentNode
        e = (if c.support.parentNode and e and e.nodeType is 11 and e.childNodes.length is @length then fragment: e else sa(a, this, o))
        k = e.fragment
        if j = (if k.childNodes.length is 1 then (k = k.firstChild) else k.firstChild)
          b = b and c.nodeName(j, "tr")
          n = 0
          r = @length

          while n < r
            d.call (if b then f(this[n], j) else this[n]), (if n > 0 or e.cacheable or @length > 1 then k.cloneNode(true) else k)
            n++
        o.length and c.each(o, Qa)
      this

  c.fragments = {}
  c.each
    appendTo: "append"
    prependTo: "prepend"
    insertBefore: "before"
    insertAfter: "after"
    replaceAll: "replaceWith"
  , (a, b) ->
    c.fn[a] = (d) ->
      f = []
      d = c(d)
      e = @length is 1 and this[0].parentNode
      if e and e.nodeType is 11 and e.childNodes.length is 1 and d.length is 1
        d[b] this[0]
        this
      else
        e = 0
        j = d.length

        while e < j
          i = ((if e > 0 then @clone(true) else this)).get()
          c.fn[b].apply c(d[e]), i
          f = f.concat(i)
          e++
        @pushStack f, a, d.selector

  c.extend
    clean: (a, b, d, f) ->
      b = b or s
      b = b.ownerDocument or b[0] and b[0].ownerDocument or s  if typeof b.createElement is "undefined"
      e = []
      j = 0
      i = undefined

      while (i = a[j])?
        i += ""  if typeof i is "number"
        if i
          if typeof i is "string" and not jb.test(i)
            i = b.createTextNode(i)
          else if typeof i is "string"
            i = i.replace(Ka, Ma)
            o = (La.exec(i) or ["", ""])[1].toLowerCase()
            k = F[o] or F._default
            n = k[0]
            r = b.createElement("div")
            r.innerHTML = k[1] + i + k[2]
            while n--
              r = r.lastChild
            unless c.support.tbody
              n = ib.test(i)
              o = (if o is "table" and not n then r.firstChild and r.firstChild.childNodes else (if k[1] is "<table>" and not n then r.childNodes else []))
              k = o.length - 1
              while k >= 0
                c.nodeName(o[k], "tbody") and not o[k].childNodes.length and o[k].parentNode.removeChild(o[k])
                --k
            not c.support.leadingWhitespace and V.test(i) and r.insertBefore(b.createTextNode(V.exec(i)[0]), r.firstChild)
            i = r.childNodes
          if i.nodeType
            e.push i
          else
            e = c.merge(e, i)
        j++
      if d
        j = 0
        while e[j]
          unless f and c.nodeName(e[j], "script") and (not e[j].type or e[j].type.toLowerCase() is "text/javascript")
            e[j].nodeType is 1 and e.splice.apply(e, [j + 1, 0].concat(c.makeArray(e[j].getElementsByTagName("script"))))
            d.appendChild e[j]
          j++
      e

    cleanData: (a) ->
      b = undefined
      d = undefined
      f = c.cache
      e = c.event.special
      j = c.support.deleteExpando
      i = 0
      o = undefined

      while (o = a[i])?
        if d = o[c.expando]
          b = f[d]
          if b.events
            for k of b.events
              (if e[k] then c.event.remove(o, k) else Ca(o, k, b.handle))
          if j
            delete o[c.expando]
          else
            o.removeAttribute and o.removeAttribute(c.expando)
          delete f[d]
        i++

  kb = /z-?index|font-?weight|opacity|zoom|line-?height/i
  Na = /alpha\([^)]*\)/
  Oa = /opacity=([^)]*)/
  ha = /float/i
  ia = /-([a-z])/g
  lb = /([A-Z])/g
  mb = /^-?\d+(?:px)?$/i
  nb = /^-?\d/
  ob =
    position: "absolute"
    visibility: "hidden"
    display: "block"

  pb = ["Left", "Right"]
  qb = ["Top", "Bottom"]
  rb = s.defaultView and s.defaultView.getComputedStyle
  Pa = (if c.support.cssFloat then "cssFloat" else "styleFloat")
  ja = (a, b) ->
    b.toUpperCase()

  c.fn.css = (a, b) ->
    X this, a, b, true, (d, f, e) ->
      return c.curCSS(d, f)  if e is w
      e += "px"  if typeof e is "number" and not kb.test(f)
      c.style d, f, e


  c.extend
    style: (a, b, d) ->
      return w  if not a or a.nodeType is 3 or a.nodeType is 8
      d = w  if (b is "width" or b is "height") and parseFloat(d) < 0
      f = a.style or a
      e = d isnt w
      if not c.support.opacity and b is "opacity"
        if e
          f.zoom = 1
          b = (if parseInt(d, 10) + "" is "NaN" then "" else "alpha(opacity=" + d * 100 + ")")
          a = f.filter or c.curCSS(a, "filter") or ""
          f.filter = (if Na.test(a) then a.replace(Na, b) else b)
        return (if f.filter and f.filter.indexOf("opacity=") >= 0 then parseFloat(Oa.exec(f.filter)[1]) / 100 + "" else "")
      b = Pa  if ha.test(b)
      b = b.replace(ia, ja)
      f[b] = d  if e
      f[b]

    css: (a, b, d, f) ->
      if b is "width" or b is "height"
        i = ->
          e = (if b is "width" then a.offsetWidth else a.offsetHeight)
          f isnt "border" and c.each(j, ->
            f or (e -= parseFloat(c.curCSS(a, "padding" + this, true)) or 0)
            if f is "margin"
              e += parseFloat(c.curCSS(a, "margin" + this, true)) or 0
            else
              e -= parseFloat(c.curCSS(a, "border" + this + "Width", true)) or 0
          )
        e = undefined
        j = (if b is "width" then pb else qb)
        (if a.offsetWidth isnt 0 then i() else c.swap(a, ob, i))
        return Math.max(0, Math.round(e))
      c.curCSS a, b, d

    curCSS: (a, b, d) ->
      f = undefined
      e = a.style
      if not c.support.opacity and b is "opacity" and a.currentStyle
        f = (if Oa.test(a.currentStyle.filter or "") then parseFloat(RegExp.$1) / 100 + "" else "")
        return (if f is "" then "1" else f)
      b = Pa  if ha.test(b)
      if not d and e and e[b]
        f = e[b]
      else if rb
        b = "float"  if ha.test(b)
        b = b.replace(lb, "-$1").toLowerCase()
        e = a.ownerDocument.defaultView
        return null  unless e
        f = a.getPropertyValue(b)  if a = e.getComputedStyle(a, null)
        f = "1"  if b is "opacity" and f is ""
      else if a.currentStyle
        d = b.replace(ia, ja)
        f = a.currentStyle[b] or a.currentStyle[d]
        if not mb.test(f) and nb.test(f)
          b = e.left
          j = a.runtimeStyle.left
          a.runtimeStyle.left = a.currentStyle.left
          e.left = (if d is "fontSize" then "1em" else f or 0)
          f = e.pixelLeft + "px"
          e.left = b
          a.runtimeStyle.left = j
      f

    swap: (a, b, d) ->
      f = {}
      for e of b
        f[e] = a.style[e]
        a.style[e] = b[e]
      d.call a
      for e of b
        a.style[e] = f[e]

  if c.expr and c.expr.filters
    c.expr.filters.hidden = (a) ->
      b = a.offsetWidth
      d = a.offsetHeight
      f = a.nodeName.toLowerCase() is "tr"
      (if b is 0 and d is 0 and not f then true else (if b > 0 and d > 0 and not f then false else c.curCSS(a, "display") is "none"))

    c.expr.filters.visible = (a) ->
      not c.expr.filters.hidden(a)
  sb = J()
  tb = /<script(.|\s)*?\/script>/g
  ub = /select|textarea/i
  vb = /color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i
  N = RegExp("=\\?(&|$)")
  ka = /\?/
  wb = /(\?|&)_=.*?(&|$)/
  xb = /^(\w+:)?\/\/([^\/?#]+)/
  yb = /%20/g
  zb = c.fn.load
  c.fn.extend
    load: (a, b, d) ->
      if typeof a isnt "string"
        return zb.call(this, a)
      else return this  unless @length
      f = a.indexOf(" ")
      if f >= 0
        e = a.slice(f, a.length)
        a = a.slice(0, f)
      f = "GET"
      if b
        if c.isFunction(b)
          d = b
          b = null
        else if typeof b is "object"
          b = c.param(b, c.ajaxSettings.traditional)
          f = "POST"
      j = this
      c.ajax
        url: a
        type: f
        dataType: "html"
        data: b
        complete: (i, o) ->
          j.html (if e then c("<div />").append(i.responseText.replace(tb, "")).find(e) else i.responseText)  if o is "success" or o is "notmodified"
          d and j.each(d, [i.responseText, o, i])

      this

    serialize: ->
      c.param @serializeArray()

    serializeArray: ->
      @map(->
        (if @elements then c.makeArray(@elements) else this)
      ).filter(->
        @name and not @disabled and (@checked or ub.test(@nodeName) or vb.test(@type))
      ).map((a, b) ->
        a = c(this).val()
        (if not a? then null else (if c.isArray(a) then c.map(a, (d) ->
          name: b.name
          value: d
        ) else
          name: b.name
          value: a
        ))
      ).get()

  c.each "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), (a, b) ->
    c.fn[b] = (d) ->
      @bind b, d

  c.extend
    get: (a, b, d, f) ->
      if c.isFunction(b)
        f = f or d
        d = b
        b = null
      c.ajax
        type: "GET"
        url: a
        data: b
        success: d
        dataType: f


    getScript: (a, b) ->
      c.get a, null, b, "script"

    getJSON: (a, b, d) ->
      c.get a, b, d, "json"

    post: (a, b, d, f) ->
      if c.isFunction(b)
        f = f or d
        d = b
        b = {}
      c.ajax
        type: "POST"
        url: a
        data: b
        success: d
        dataType: f


    ajaxSetup: (a) ->
      c.extend c.ajaxSettings, a

    ajaxSettings:
      url: location.href
      global: true
      type: "GET"
      contentType: "application/x-www-form-urlencoded"
      processData: true
      async: true
      xhr: (if A.XMLHttpRequest and (A.location.protocol isnt "file:" or not A.ActiveXObject) then ->
        new A.XMLHttpRequest
       else ->
        try
          return new A.ActiveXObject("Microsoft.XMLHTTP")
      )
      accepts:
        xml: "application/xml, text/xml"
        html: "text/html"
        script: "text/javascript, application/javascript"
        json: "application/json, text/javascript"
        text: "text/plain"
        _default: "*/*"

    lastModified: {}
    etag: {}
    ajax: (a) ->
      b = ->
        e.success and e.success.call(k, o, i, x)
        e.global and f("ajaxSuccess", [x, e])
      d = ->
        e.complete and e.complete.call(k, x, i)
        e.global and f("ajaxComplete", [x, e])
        e.global and not --c.active and c.event.trigger("ajaxStop")
      f = (q, p) ->
        ((if e.context then c(e.context) else c.event)).trigger q, p
      e = c.extend(true, {}, c.ajaxSettings, a)
      j = undefined
      i = undefined
      o = undefined
      k = a and a.context or e
      n = e.type.toUpperCase()
      e.data = c.param(e.data, e.traditional)  if e.data and e.processData and typeof e.data isnt "string"
      if e.dataType is "jsonp"
        if n is "GET"
          N.test(e.url) or (e.url += ((if ka.test(e.url) then "&" else "?")) + (e.jsonp or "callback") + "=?")
        else e.data = ((if e.data then e.data + "&" else "")) + (e.jsonp or "callback") + "=?"  if not e.data or not N.test(e.data)
        e.dataType = "json"
      if e.dataType is "json" and (e.data and N.test(e.data) or N.test(e.url))
        j = e.jsonpCallback or "jsonp" + sb++
        e.data = (e.data + "").replace(N, "=" + j + "$1")  if e.data
        e.url = e.url.replace(N, "=" + j + "$1")
        e.dataType = "script"
        A[j] = A[j] or (q) ->
          o = q
          b()
          d()
          A[j] = w
          try
            delete A[j]
          z and z.removeChild(C)
      e.cache = false  if e.dataType is "script" and e.cache is null
      if e.cache is false and n is "GET"
        r = J()
        u = e.url.replace(wb, "$1_=" + r + "$2")
        e.url = u + ((if u is e.url then ((if ka.test(e.url) then "&" else "?")) + "_=" + r else ""))
      e.url += ((if ka.test(e.url) then "&" else "?")) + e.data  if e.data and n is "GET"
      e.global and not c.active++ and c.event.trigger("ajaxStart")
      r = (r = xb.exec(e.url)) and (r[1] and r[1] isnt location.protocol or r[2] isnt location.host)
      if e.dataType is "script" and n is "GET" and r
        z = s.getElementsByTagName("head")[0] or s.documentElement
        C = s.createElement("script")
        C.src = e.url
        C.charset = e.scriptCharset  if e.scriptCharset
        unless j
          B = false
          C.onload = C.onreadystatechange = ->
            if not B and (not @readyState or @readyState is "loaded" or @readyState is "complete")
              B = true
              b()
              d()
              C.onload = C.onreadystatechange = null
              z and C.parentNode and z.removeChild(C)
        z.insertBefore C, z.firstChild
        return w
      E = false
      x = e.xhr()
      if x
        (if e.username then x.open(n, e.url, e.async, e.username, e.password) else x.open(n, e.url, e.async))
        try
          x.setRequestHeader "Content-Type", e.contentType  if e.data or a and a.contentType
          if e.ifModified
            c.lastModified[e.url] and x.setRequestHeader("If-Modified-Since", c.lastModified[e.url])
            c.etag[e.url] and x.setRequestHeader("If-None-Match", c.etag[e.url])
          r or x.setRequestHeader("X-Requested-With", "XMLHttpRequest")
          x.setRequestHeader "Accept", (if e.dataType and e.accepts[e.dataType] then e.accepts[e.dataType] + ", */*" else e.accepts._default)
        if e.beforeSend and e.beforeSend.call(k, x, e) is false
          e.global and not --c.active and c.event.trigger("ajaxStop")
          x.abort()
          return false
        e.global and f("ajaxSend", [x, e])
        g = x.onreadystatechange = (q) ->
          if not x or x.readyState is 0 or q is "abort"
            E or d()
            E = true
            x.onreadystatechange = c.noop  if x
          else if not E and x and (x.readyState is 4 or q is "timeout")
            E = true
            x.onreadystatechange = c.noop
            i = (if q is "timeout" then "timeout" else (if not c.httpSuccess(x) then "error" else (if e.ifModified and c.httpNotModified(x, e.url) then "notmodified" else "success")))
            p = undefined
            if i is "success"
              try
                o = c.httpData(x, e.dataType, e)
              catch v
                i = "parsererror"
                p = v
            if i is "success" or i is "notmodified"
              j or b()
            else
              c.handleError e, x, i, p
            d()
            q is "timeout" and x.abort()
            x = null  if e.async

        try
          h = x.abort
          x.abort = ->
            x and h.call(x)
            g "abort"
        e.async and e.timeout > 0 and setTimeout(->
          x and not E and g("timeout")
        , e.timeout)
        try
          x.send (if n is "POST" or n is "PUT" or n is "DELETE" then e.data else null)
        catch m
          c.handleError e, x, null, m
          d()
        e.async or g()
        x

    handleError: (a, b, d, f) ->
      a.error.call a.context or a, b, d, f  if a.error
      ((if a.context then c(a.context) else c.event)).trigger "ajaxError", [b, a, f]  if a.global

    active: 0
    httpSuccess: (a) ->
      try
        return not a.status and location.protocol is "file:" or a.status >= 200 and a.status < 300 or a.status is 304 or a.status is 1223 or a.status is 0
      false

    httpNotModified: (a, b) ->
      d = a.getResponseHeader("Last-Modified")
      f = a.getResponseHeader("Etag")
      c.lastModified[b] = d  if d
      c.etag[b] = f  if f
      a.status is 304 or a.status is 0

    httpData: (a, b, d) ->
      f = a.getResponseHeader("content-type") or ""
      e = b is "xml" or not b and f.indexOf("xml") >= 0
      a = (if e then a.responseXML else a.responseText)
      e and a.documentElement.nodeName is "parsererror" and c.error("parsererror")
      a = d.dataFilter(a, b)  if d and d.dataFilter
      if typeof a is "string"
        if b is "json" or not b and f.indexOf("json") >= 0
          a = c.parseJSON(a)
        else c.globalEval a  if b is "script" or not b and f.indexOf("javascript") >= 0
      a

    param: (a, b) ->
      d = (i, o) ->
        if c.isArray(o)
          c.each o, (k, n) ->
            (if b or /\[\]$/.test(i) then f(i, n) else d(i + "[" + ((if typeof n is "object" or c.isArray(n) then k else "")) + "]", n))

        else
          (if not b and o? and typeof o is "object" then c.each(o, (k, n) ->
            d i + "[" + k + "]", n
          ) else f(i, o))
      f = (i, o) ->
        o = (if c.isFunction(o) then o() else o)
        e[e.length] = encodeURIComponent(i) + "=" + encodeURIComponent(o)
      e = []
      b = c.ajaxSettings.traditional  if b is w
      if c.isArray(a) or a.jquery
        c.each a, ->
          f @name, @value

      else
        for j of a
          d j, a[j]
      e.join("&").replace yb, "+"

  la = {}
  Ab = /toggle|show|hide/
  Bb = /^([+-]=)?([\d+-.]+)(.*)$/
  W = undefined
  va = [["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"], ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"], ["opacity"]]
  c.fn.extend
    show: (a, b) ->
      unless a or a is 0
        a = 0
        b = @length
        while a < b
          d = c.data(this[a], "olddisplay")
          this[a].style.display = d or ""
          if c.css(this[a], "display") is "none"
            d = this[a].nodeName
            f = undefined
            unless la[d]
              e = c("<" + d + " />").appendTo("body")
              f = e.css("display")
              f = "block"  if f is "none"
              e.remove()
              la[d] = f
            c.data this[a], "olddisplay", f
          a++
        a = 0
        b = @length
        while a < b
          this[a].style.display = c.data(this[a], "olddisplay") or ""
          a++
        this

    hide: (a, b) ->
      unless a or a is 0
        a = 0
        b = @length
        while a < b
          d = c.data(this[a], "olddisplay")
          not d and d isnt "none" and c.data(this[a], "olddisplay", c.css(this[a], "display"))
          a++
        a = 0
        b = @length
        while a < b
          this[a].style.display = "none"
          a++
        this

    _toggle: c.fn.toggle
    toggle: (a, b) ->
      d = typeof a is "boolean"
      if c.isFunction(a) and c.isFunction(b)
        @_toggle.apply this, arguments_
      else
        (if not a? or d then @each(->
          f = (if d then a else c(this).is(":hidden"))
          c(this)[(if f then "show" else "hide")]()
        ) else @animate(K("toggle", 3), a, b))
      this

    fadeTo: (a, b, d) ->
      @filter(":hidden").css("opacity", 0).show().end().animate
        opacity: b
      , a, d

    animate: (a, b, d, f) ->
      e = c.speed(b, d, f)
      return @each(e.complete)  if c.isEmptyObject(a)
      this[(if e.queue is false then "each" else "queue")] ->
        j = c.extend({}, e)
        i = undefined
        o = @nodeType is 1 and c(this).is(":hidden")
        k = this
        for i of a
          n = i.replace(ia, ja)
          if i isnt n
            a[n] = a[i]
            delete a[i]

            i = n
          return j.complete.call(this)  if a[i] is "hide" and o or a[i] is "show" and not o
          if (i is "height" or i is "width") and @style
            j.display = c.css(this, "display")
            j.overflow = @style.overflow
          if c.isArray(a[i])
            (j.specialEasing = j.specialEasing or {})[i] = a[i][1]
            a[i] = a[i][0]
        @style.overflow = "hidden"  if j.overflow?
        j.curAnim = c.extend({}, a)
        c.each a, (r, u) ->
          z = new c.fx(k, j, r)
          unless Ab.test(u)
            C = Bb.exec(u)
            B = z.cur(true) or 0
            if C
              u = parseFloat(C[2])
              E = C[3] or "px"
              if E isnt "px"
                k.style[r] = (u or 1) + E
                B = (u or 1) / z.cur(true) * B
                k.style[r] = B + E
              u = ((if C[1] is "-=" then -1 else 1)) * u + B  if C[1]
              z.custom B, u, E
            else
              z.custom B, u, ""

        true


    stop: (a, b) ->
      d = c.timers
      a and @queue([])
      @each ->
        f = d.length - 1

        while f >= 0
          if d[f].elem is this
            b and d[f](true)
            d.splice f, 1
          f--

      b or @dequeue()
      this

  c.each
    slideDown: K("show", 1)
    slideUp: K("hide", 1)
    slideToggle: K("toggle", 1)
    fadeIn:
      opacity: "show"

    fadeOut:
      opacity: "hide"
  , (a, b) ->
    c.fn[a] = (d, f) ->
      @animate b, d, f

  c.extend
    speed: (a, b, d) ->
      f = (if a and typeof a is "object" then a else
        complete: d or not d and b or c.isFunction(a) and a
        duration: a
        easing: d and b or b and not c.isFunction(b) and b
      )
      f.duration = (if c.fx.off then 0 else (if typeof f.duration is "number" then f.duration else c.fx.speeds[f.duration] or c.fx.speeds._default))
      f.old = f.complete
      f.complete = ->
        f.queue isnt false and c(this).dequeue()
        c.isFunction(f.old) and f.old.call(this)

      f

    easing:
      linear: (a, b, d, f) ->
        d + f * a

      swing: (a, b, d, f) ->
        (-Math.cos(a * Math.PI) / 2 + 0.5) * f + d

    timers: []
    fx: (a, b, d) ->
      @options = b
      @elem = a
      @prop = d
      b.orig = {}  unless b.orig

  c.fx:: =
    update: ->
      @options.step and @options.step.call(@elem, @now, this)
      (c.fx.step[@prop] or c.fx.step._default) this
      @elem.style.display = "block"  if (@prop is "height" or @prop is "width") and @elem.style

    cur: (a) ->
      return @elem[@prop]  if @elem[@prop]? and (not @elem.style or not @elem.style[@prop]?)
      (if (a = parseFloat(c.css(@elem, @prop, a))) and a > -10000 then a else parseFloat(c.curCSS(@elem, @prop)) or 0)

    custom: (a, b, d) ->
      f = (j) ->
        e.step j
      @startTime = J()
      @start = a
      @end = b
      @unit = d or @unit or "px"
      @now = @start
      @pos = @state = 0
      e = this
      f.elem = @elem
      W = setInterval(c.fx.tick, 13)  if f() and c.timers.push(f) and not W

    show: ->
      @options.orig[@prop] = c.style(@elem, @prop)
      @options.show = true
      @custom (if @prop is "width" or @prop is "height" then 1 else 0), @cur()
      c(@elem).show()

    hide: ->
      @options.orig[@prop] = c.style(@elem, @prop)
      @options.hide = true
      @custom @cur(), 0

    step: (a) ->
      b = J()
      d = true
      if a or b >= @options.duration + @startTime
        @now = @end
        @pos = @state = 1
        @update()
        @options.curAnim[@prop] = true
        for f of @options.curAnim
          d = false  if @options.curAnim[f] isnt true
        if d
          if @options.display?
            @elem.style.overflow = @options.overflow
            a = c.data(@elem, "olddisplay")
            @elem.style.display = (if a then a else @options.display)
            @elem.style.display = "block"  if c.css(@elem, "display") is "none"
          @options.hide and c(@elem).hide()
          if @options.hide or @options.show
            for e of @options.curAnim
              c.style @elem, e, @options.orig[e]
          @options.complete.call @elem
        return false
      else
        e = b - @startTime
        @state = e / @options.duration
        a = @options.easing or ((if c.easing.swing then "swing" else "linear"))
        @pos = c.easing[@options.specialEasing and @options.specialEasing[@prop] or a](@state, e, 0, 1, @options.duration)
        @now = @start + (@end - @start) * @pos
        @update()
      true

  c.extend c.fx,
    tick: ->
      a = c.timers
      b = 0

      while b < a.length
        a[b]() or a.splice(b--, 1)
        b++
      a.length or c.fx.stop()

    stop: ->
      clearInterval W
      W = null

    speeds:
      slow: 600
      fast: 200
      _default: 400

    step:
      opacity: (a) ->
        c.style a.elem, "opacity", a.now

      _default: (a) ->
        if a.elem.style and a.elem.style[a.prop]?
          a.elem.style[a.prop] = ((if a.prop is "width" or a.prop is "height" then Math.max(0, a.now) else a.now)) + a.unit
        else
          a.elem[a.prop] = a.now

  if c.expr and c.expr.filters
    c.expr.filters.animated = (a) ->
      c.grep(c.timers, (b) ->
        a is b.elem
      ).length
  c.fn.offset = (if "getBoundingClientRect" of s.documentElement then (a) ->
    b = this[0]
    if a
      return @each((e) ->
        c.offset.setOffset this, a, e
      )
    return null  if not b or not b.ownerDocument
    return c.offset.bodyOffset(b)  if b is b.ownerDocument.body
    d = b.getBoundingClientRect()
    f = b.ownerDocument
    b = f.body
    f = f.documentElement
    top: d.top + (self.pageYOffset or c.support.boxModel and f.scrollTop or b.scrollTop) - (f.clientTop or b.clientTop or 0)
    left: d.left + (self.pageXOffset or c.support.boxModel and f.scrollLeft or b.scrollLeft) - (f.clientLeft or b.clientLeft or 0)
   else (a) ->
    b = this[0]
    if a
      return @each((r) ->
        c.offset.setOffset this, a, r
      )
    return null  if not b or not b.ownerDocument
    return c.offset.bodyOffset(b)  if b is b.ownerDocument.body
    c.offset.initialize()
    d = b.offsetParent
    f = b
    e = b.ownerDocument
    j = undefined
    i = e.documentElement
    o = e.body
    f = (if (e = e.defaultView) then e.getComputedStyle(b, null) else b.currentStyle)
    k = b.offsetTop
    n = b.offsetLeft

    while (b = b.parentNode) and b isnt o and b isnt i
      break  if c.offset.supportsFixedPosition and f.position is "fixed"
      j = (if e then e.getComputedStyle(b, null) else b.currentStyle)
      k -= b.scrollTop
      n -= b.scrollLeft
      if b is d
        k += b.offsetTop
        n += b.offsetLeft
        if c.offset.doesNotAddBorder and not (c.offset.doesAddBorderForTableAndCells and /^t(able|d|h)$/i.test(b.nodeName))
          k += parseFloat(j.borderTopWidth) or 0
          n += parseFloat(j.borderLeftWidth) or 0
        f = d
        d = b.offsetParent
      if c.offset.subtractsBorderForOverflowNotVisible and j.overflow isnt "visible"
        k += parseFloat(j.borderTopWidth) or 0
        n += parseFloat(j.borderLeftWidth) or 0
      f = j
    if f.position is "relative" or f.position is "static"
      k += o.offsetTop
      n += o.offsetLeft
    if c.offset.supportsFixedPosition and f.position is "fixed"
      k += Math.max(i.scrollTop, o.scrollTop)
      n += Math.max(i.scrollLeft, o.scrollLeft)
    top: k
    left: n
  )
  c.offset =
    initialize: ->
      a = s.body
      b = s.createElement("div")
      d = undefined
      f = undefined
      e = undefined
      j = parseFloat(c.curCSS(a, "marginTop", true)) or 0
      c.extend b.style,
        position: "absolute"
        top: 0
        left: 0
        margin: 0
        border: 0
        width: "1px"
        height: "1px"
        visibility: "hidden"

      b.innerHTML = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>"
      a.insertBefore b, a.firstChild
      d = b.firstChild
      f = d.firstChild
      e = d.nextSibling.firstChild.firstChild
      @doesNotAddBorder = f.offsetTop isnt 5
      @doesAddBorderForTableAndCells = e.offsetTop is 5
      f.style.position = "fixed"
      f.style.top = "20px"
      @supportsFixedPosition = f.offsetTop is 20 or f.offsetTop is 15
      f.style.position = f.style.top = ""
      d.style.overflow = "hidden"
      d.style.position = "relative"
      @subtractsBorderForOverflowNotVisible = f.offsetTop is -5
      @doesNotIncludeMarginInBodyOffset = a.offsetTop isnt j
      a.removeChild b
      c.offset.initialize = c.noop

    bodyOffset: (a) ->
      b = a.offsetTop
      d = a.offsetLeft
      c.offset.initialize()
      if c.offset.doesNotIncludeMarginInBodyOffset
        b += parseFloat(c.curCSS(a, "marginTop", true)) or 0
        d += parseFloat(c.curCSS(a, "marginLeft", true)) or 0
      top: b
      left: d

    setOffset: (a, b, d) ->
      a.style.position = "relative"  if /static/.test(c.curCSS(a, "position"))
      f = c(a)
      e = f.offset()
      j = parseInt(c.curCSS(a, "top", true), 10) or 0
      i = parseInt(c.curCSS(a, "left", true), 10) or 0
      b = b.call(a, d, e)  if c.isFunction(b)
      d =
        top: b.top - e.top + j
        left: b.left - e.left + i

      (if "using" of b then b.using.call(a, d) else f.css(d))

  c.fn.extend
    position: ->
      return null  unless this[0]
      a = this[0]
      b = @offsetParent()
      d = @offset()
      f = (if /^body|html$/i.test(b[0].nodeName) then
        top: 0
        left: 0
       else b.offset())
      d.top -= parseFloat(c.curCSS(a, "marginTop", true)) or 0
      d.left -= parseFloat(c.curCSS(a, "marginLeft", true)) or 0
      f.top += parseFloat(c.curCSS(b[0], "borderTopWidth", true)) or 0
      f.left += parseFloat(c.curCSS(b[0], "borderLeftWidth", true)) or 0
      top: d.top - f.top
      left: d.left - f.left

    offsetParent: ->
      @map ->
        a = @offsetParent or s.body

        while a and not /^body|html$/i.test(a.nodeName) and c.css(a, "position") is "static"
          a = a.offsetParent
        a


  c.each ["Left", "Top"], (a, b) ->
    d = "scroll" + b
    c.fn[d] = (f) ->
      e = this[0]
      j = undefined
      return null  unless e
      if f isnt w
        @each ->
          if j = wa(this)
            j.scrollTo (if not a then f else c(j).scrollLeft()), (if a then f else c(j).scrollTop())
          else
            this[d] = f

      else
        (if (j = wa(e)) then (if "pageXOffset" of j then j[(if a then "pageYOffset" else "pageXOffset")] else c.support.boxModel and j.document.documentElement[d] or j.document.body[d]) else e[d])

  c.each ["Height", "Width"], (a, b) ->
    d = b.toLowerCase()
    c.fn["inner" + b] = ->
      (if this[0] then c.css(this[0], d, false, "padding") else null)

    c.fn["outer" + b] = (f) ->
      (if this[0] then c.css(this[0], d, false, (if f then "margin" else "border")) else null)

    c.fn[d] = (f) ->
      e = this[0]
      return (if not f? then null else this)  unless e
      if c.isFunction(f)
        return @each((j) ->
          i = c(this)
          i[d] f.call(this, j, i[d]())
        )
      (if "scrollTo" of e and e.document then e.document.compatMode is "CSS1Compat" and e.document.documentElement["client" + b] or e.document.body["client" + b] else (if e.nodeType is 9 then Math.max(e.documentElement["client" + b], e.body["scroll" + b], e.documentElement["scroll" + b], e.body["offset" + b], e.documentElement["offset" + b]) else (if f is w then c.css(e, d) else @css(d, (if typeof f is "string" then f else f + "px")))))

  A.jQuery = A.$ = c
) window
